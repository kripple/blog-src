<!DOCTYPE html><html lang="en-us"><head><link href="http://gmpg.org/xfn/11" rel="profile"><meta content="IE=edge" http-equiv="X-UA-Compatible"><meta content="text/html; charset=utf-8" http-equiv="content-type"><meta content="width=device-width,initial-scale=1,maximum-scale=1" name="viewport"><title>Hash-tastic</title><link href="/public/css/style.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Karma:400,400italic,700|Righteous" rel="stylesheet" type="text/css"><script src="/public/js/analytics.js"></script><link href="/public/apple-touch-icon-144-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144"><link href="/public/imgs/favicon.ico" rel="shortcut icon"><link href="/atom.xml" rel="alternate" type="application/rss+xml" title="RSS"></head><body class="theme-base-0g"><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><h1><a href="/">Kelly Ripple</a></h1><p class="lead">Software Engineer</p></div><nav class="sidebar-nav"><a href="/" class="sidebar-nav-item">About</a> <a href="/projects" class="sidebar-nav-item">Projects</a> <a href="/blog" class="sidebar-nav-item">Blog</a></nav><p>&copy; 2016. Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&amp;<a href="https://github.com/poole/hyde" target="_blank">Hyde</a>.</p></div></div><div class="container content"><div class="post"><h1 class="post-title">Hash-tastic</h1><span class="post-date">June 8, 2015 &middot; <span class="reading-time" title="Estimated read time">3 Minute Read</span></span><section><p>This week I learned about the glorious data storage object that is the Hash. The following will be some fun information on how to differentiate, define, and reference arrays and hashes. Arrays and hashes are both constucts used for data storage. Their construction and syntax are different, so depending on what you're trying to do, one will likely be better than the other for specific applications.</p></section><section><h2>Define</h2><h4>Array</h4><p>Ordered, iteger-indexed collections of any object. Array indexing starts at 0 and goes to (n-1), where n is the number of array indices. A negative index is assumed to be relative to the end of the arrayâ€”that is, an index of -1 indicates the last element of the array, -2 is the next to last element in the array, and so on.</p><h4>Hash</h4><p>A collection of key-value pairs. Indexing is done via arbitrary keys of any object type. Hashes order their values in the sequence that the corresponding keys were inserted. By default, hashes return 'nil' when accessing keys that do not exist in the hash. It's possible to define this value to something other than 'nil' (see below).</p></section><section><h2>Create</h2><p><code>Array.new</code> is functionally the same as <code>array = []</code> for creating a new array, except <code>Array.new</code> has some fun options for initializing the array however you like. For example:</p><p></p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Array</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># =&gt; []</span>
<span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; [nil,nil]</span>
<span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s2">"apple"</span><span class="p">)</span> <span class="c1"># =&gt; ["apple","apple","apple"]</span></code></pre></figure><p></p><p>Or the following:</p><p></p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">example_array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">copycat_array</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">example_array</span><span class="p">)</span> <span class="c1"># =&gt; [1,2,3]</span></code></pre></figure><p></p><p>The procedure for creating a new hash is all but identical: <code>Hash.new</code>, or <code>hash = {}</code>. Similarly, <code>Hash.new</code> can do the following:</p><p></p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># =&gt; {}</span>
<span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; {}</span>
<span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s2">"apple"</span><span class="p">)</span> <span class="c1"># =&gt; probably a syntax error (don't do this)</span></code></pre></figure><p></p><p>The <code>Hash.new(argument)</code> is the default value for accessing keys that do not exist in the hash. If you were to create an empty hash with the argument '2', and then try to access a nonexistent key (since our hash is empty in this example, ALL keys are nonexistent), the hash would return '2' instead of returning 'nil'.</p></section><section><h2>Access</h2><p>This is the easiest part:</p><p></p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="n">array</span><span class="p">[</span><span class="n">integer</span><span class="p">]</span> <span class="c1"># =&gt; value of the array at the specified integer </span>
<span class="nb">puts</span> <span class="nb">hash</span><span class="p">[</span><span class="s2">"key"</span><span class="p">]</span> <span class="c1"># =&gt; value of the hash at the specified key</span></code></pre></figure><p></p><p>Arrays have integer index-value pairs, hashes have key-value pairs. Try creating and then accessing array/hash values at indices/keys that do not exist. That way, you'll be able to recognize it if you ever do it unintentionally.</p><h2>Bonus</h2><p></p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="n">array</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># =&gt; index of the array at the specified value</span>
<span class="nb">puts</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">key</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># =&gt; key of the hash at the specified value</span></code></pre></figure><p></p><p>For duplicate values at different indices/keys, the above two statements will return the first index/key that corresponds to the specified value. But don't take my word for it, try it for yourself!</p></section></div><div class="related"><h2>Related Posts</h2><ul class="related-posts"><li><h3><a href="/godaddy-github-pages">GoDaddy + Github Pages <small>July 23, 2015</small></a></h3></li><li><h3><a href="/how-the-internet-works">How the Internet Works <small>July 13, 2015</small></a></h3></li><li><h3><a href="/ruby-vs-javascript">Ruby vs. JavaScript <small>July 12, 2015</small></a></h3></li><li><h3><a href="/ruby-building-blocks">Ruby Building Blocks <small>June 22, 2015</small></a></h3></li><li><h3><a href="/lets-get-classy">Let's Get Classy <small>June 21, 2015</small></a></h3></li><li><h3><a href="/method-map">Method&#58; Map <small>June 14, 2015</small></a></h3></li><li><h3><a href="/css-madness">CSS Madness <small>May 30, 2015</small></a></h3></li><li><h3><a href="/git-vs-github">Git vs. Github <small>May 24, 2015</small></a></h3></li></ul></div></div></body></html>